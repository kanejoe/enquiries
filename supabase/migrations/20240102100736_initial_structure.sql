create table "public"."precedents" (
    "id" bigint generated always as identity not null,
    "name" text not null,
    "subname" text not null,
    "is_locked" boolean not null default false,
    "asset_id" bigint,
    "is_archived" boolean default false,
    "created_at" date default now(),
    "created_by" text default ''::text
);


create table "public"."properties" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "property" text,
    "eircode" text,
    "vendor" text,
    "category" text,
    "status" text,
    "is_archived" boolean default false
);


create table "public"."requisitions" (
    "id" bigint generated always as identity not null,
    "parent_id" integer,
    "sequence" integer not null default 1,
    "query" text,
    "reply" text,
    "is_applicable" boolean not null default false,
    "has_doc" boolean not null default false,
    "is_complete" boolean not null default false,
    "is_flagged" boolean not null default false,
    "is_required" boolean not null default true,
    "precedent_id" bigint,
    "is_locked" boolean not null default false,
    "is_archived" boolean default false
);


CREATE UNIQUE INDEX precedents_pkey ON public.precedents USING btree (id);

CREATE UNIQUE INDEX properties_pkey ON public.properties USING btree (id);

CREATE UNIQUE INDEX requisitions_pkey ON public.requisitions USING btree (id);

alter table "public"."precedents" add constraint "precedents_pkey" PRIMARY KEY using index "precedents_pkey";

alter table "public"."properties" add constraint "properties_pkey" PRIMARY KEY using index "properties_pkey";

alter table "public"."requisitions" add constraint "requisitions_pkey" PRIMARY KEY using index "requisitions_pkey";

alter table "public"."requisitions" add constraint "requisitions_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES requisitions(id) not valid;

alter table "public"."requisitions" validate constraint "requisitions_parent_id_fkey";

alter table "public"."requisitions" add constraint "requisitions_precedent_id_fkey" FOREIGN KEY (precedent_id) REFERENCES precedents(id) not valid;

alter table "public"."requisitions" validate constraint "requisitions_precedent_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.adjust_sequence(p_parent_id integer, p_new_sequence integer, p_old_sequence integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    
    -- Temporarily set the sequence of the moved item to a placeholder value (e.g., -1)
    UPDATE public.requisitions
    SET sequence = -1
    WHERE parent_id = p_parent_id AND sequence = p_old_sequence;

    -- Handle the case where the sequence is decreased
    IF p_new_sequence < p_old_sequence THEN
        UPDATE public.requisitions
        SET sequence = sequence + 1
        WHERE parent_id = p_parent_id AND sequence >= p_new_sequence AND sequence < p_old_sequence;
    END IF;

    -- Handle the case where the sequence is increased
    IF p_new_sequence > p_old_sequence THEN
        UPDATE public.requisitions
        SET sequence = sequence - 1
        WHERE parent_id = p_parent_id AND sequence <= p_new_sequence AND sequence > p_old_sequence;
    END IF;

    -- Finally, set the sequence of the moved item to the new value
    UPDATE public.requisitions
    SET sequence = p_new_sequence
    WHERE parent_id = p_parent_id AND sequence = -1;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.inc_sequence(p_parent_id integer, p_sequence_threshold integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    UPDATE public.requisitions
    SET sequence = sequence + 1
    WHERE parent_id = p_parent_id AND sequence > p_sequence_threshold;
END;$function$
;

CREATE OR REPLACE FUNCTION public.insert_and_resequence(p_query text, p_parent_id integer, p_sequence integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    max_sequence INT;
BEGIN
    -- Check if a requisition with the provided sequence already exists
    IF EXISTS (SELECT 1 FROM requisitions WHERE parent_id = p_parent_id AND sequence = p_sequence) THEN

        -- Shift sequences of subsequent requisitions to make room for new one
        UPDATE requisitions
        SET sequence = sequence + 1
        WHERE parent_id = p_parent_id AND sequence >= p_sequence;

    END IF;

    -- Insert the new requisition
    INSERT INTO requisitions (query, parent_id, sequence) VALUES (p_query, p_parent_id, p_sequence);

END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_requisition(p_id integer, p_parent_id integer, p_old_sequence integer, p_new_sequence integer, p_query text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Update the query first
    UPDATE public.requisitions
    SET query = p_query
    WHERE id = p_id;

    -- Temporarily set the sequence of the moved item to a placeholder value (e.g., -1)
    UPDATE public.requisitions
    SET sequence = -1
    WHERE id = p_id;

    -- Handle the case where the sequence is decreased
    IF p_new_sequence < p_old_sequence THEN
        UPDATE public.requisitions
        SET sequence = sequence + 1
        WHERE 
        (parent_id = p_parent_id OR (p_parent_id IS NULL AND parent_id IS NULL))
        AND sequence >= p_new_sequence AND sequence < p_old_sequence;
    END IF;

    -- Handle the case where the sequence is increased
    IF p_new_sequence > p_old_sequence THEN
        UPDATE public.requisitions
        SET sequence = sequence - 1
         WHERE 
        (parent_id = p_parent_id OR (p_parent_id IS NULL AND parent_id IS NULL))
        AND sequence <= p_new_sequence AND sequence > p_old_sequence;
    END IF;

    -- Finally, set the sequence of the moved item to the new value
    UPDATE public.requisitions
    SET sequence = p_new_sequence
    WHERE id = p_id;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_requisition(p_id integer, p_parent_id integer, p_old_sequence integer, p_new_sequence integer, p_query text, p_is_required boolean)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Update the query first
    UPDATE public.requisitions
    SET query = p_query,
        is_required = p_is_required
    WHERE id = p_id;

    -- Temporarily set the sequence of the moved item to a placeholder value (e.g., -1)
    UPDATE public.requisitions
    SET sequence = -1
    WHERE id = p_id;

    -- Handle the case where the sequence is decreased
    IF p_new_sequence < p_old_sequence THEN
        UPDATE public.requisitions
        SET sequence = sequence + 1
        WHERE parent_id = p_parent_id AND sequence >= p_new_sequence AND sequence < p_old_sequence;
    END IF;

    -- Handle the case where the sequence is increased
    IF p_new_sequence > p_old_sequence THEN
        UPDATE public.requisitions
        SET sequence = sequence - 1
        WHERE parent_id = p_parent_id AND sequence <= p_new_sequence AND sequence > p_old_sequence;
    END IF;

    -- Finally, set the sequence of the moved item to the new value
    UPDATE public.requisitions
    SET sequence = p_new_sequence
    WHERE id = p_id;

END;
$function$
;

grant delete on table "public"."precedents" to "anon";

grant insert on table "public"."precedents" to "anon";

grant references on table "public"."precedents" to "anon";

grant select on table "public"."precedents" to "anon";

grant trigger on table "public"."precedents" to "anon";

grant truncate on table "public"."precedents" to "anon";

grant update on table "public"."precedents" to "anon";

grant delete on table "public"."precedents" to "authenticated";

grant insert on table "public"."precedents" to "authenticated";

grant references on table "public"."precedents" to "authenticated";

grant select on table "public"."precedents" to "authenticated";

grant trigger on table "public"."precedents" to "authenticated";

grant truncate on table "public"."precedents" to "authenticated";

grant update on table "public"."precedents" to "authenticated";

grant delete on table "public"."precedents" to "service_role";

grant insert on table "public"."precedents" to "service_role";

grant references on table "public"."precedents" to "service_role";

grant select on table "public"."precedents" to "service_role";

grant trigger on table "public"."precedents" to "service_role";

grant truncate on table "public"."precedents" to "service_role";

grant update on table "public"."precedents" to "service_role";

grant delete on table "public"."properties" to "anon";

grant insert on table "public"."properties" to "anon";

grant references on table "public"."properties" to "anon";

grant select on table "public"."properties" to "anon";

grant trigger on table "public"."properties" to "anon";

grant truncate on table "public"."properties" to "anon";

grant update on table "public"."properties" to "anon";

grant delete on table "public"."properties" to "authenticated";

grant insert on table "public"."properties" to "authenticated";

grant references on table "public"."properties" to "authenticated";

grant select on table "public"."properties" to "authenticated";

grant trigger on table "public"."properties" to "authenticated";

grant truncate on table "public"."properties" to "authenticated";

grant update on table "public"."properties" to "authenticated";

grant delete on table "public"."properties" to "service_role";

grant insert on table "public"."properties" to "service_role";

grant references on table "public"."properties" to "service_role";

grant select on table "public"."properties" to "service_role";

grant trigger on table "public"."properties" to "service_role";

grant truncate on table "public"."properties" to "service_role";

grant update on table "public"."properties" to "service_role";

grant delete on table "public"."requisitions" to "anon";

grant insert on table "public"."requisitions" to "anon";

grant references on table "public"."requisitions" to "anon";

grant select on table "public"."requisitions" to "anon";

grant trigger on table "public"."requisitions" to "anon";

grant truncate on table "public"."requisitions" to "anon";

grant update on table "public"."requisitions" to "anon";

grant delete on table "public"."requisitions" to "authenticated";

grant insert on table "public"."requisitions" to "authenticated";

grant references on table "public"."requisitions" to "authenticated";

grant select on table "public"."requisitions" to "authenticated";

grant trigger on table "public"."requisitions" to "authenticated";

grant truncate on table "public"."requisitions" to "authenticated";

grant update on table "public"."requisitions" to "authenticated";

grant delete on table "public"."requisitions" to "service_role";

grant insert on table "public"."requisitions" to "service_role";

grant references on table "public"."requisitions" to "service_role";

grant select on table "public"."requisitions" to "service_role";

grant trigger on table "public"."requisitions" to "service_role";

grant truncate on table "public"."requisitions" to "service_role";

grant update on table "public"."requisitions" to "service_role";

create policy "Enable update/all access for all users"
on "public"."requisitions"
as permissive
for all
to public;


create policy "enable read access for requisitions"
on "public"."requisitions"
as permissive
for select
to public
using (true);



create schema if not exists "utils";


